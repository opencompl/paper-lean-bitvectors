# Automaton Decision Procedure

So far, we've seen a decision procedure using the fact that bitvectors are a [[Boolean Algebra]], and one that relies on bitvectors forming a [[Commutative Ring]]. These are both well-understood mathematical structures.

However, the more interesting problems arise when we mix these two domains, that is, when we mix bitwise and arithmetic operations in a single expression.

>[!NOTE]
>Our representation of bitvectors uses twos-complement (as is standard nowadays). Moreover, our representation is *signless*. That is, the bitvector itself does not carry any information about whether it is a signed or unsigned value. Instead, when performing, say, a division operation, we specify whether we use signed division or unsigned division. We will leave this extra specification out when the operation is the same signed or unsigned (as is the case for addition, subtraction, negation)

An example of such an expression is $x - y = x + {\sim}{y} + 1$.


## 2-Adic Numbers
There are many ways to think of 2-adic numbers, but for our purposes we'll take a rather simple definition: a 2-adic number is an *infinite* sequence of bits, where a bit can be either $1$ or $0$. By convention, this infinite sequence grows to the *left*, so that the first bit in the sequence is the *least* significant.
Intuitively, we can think of 2-adics as being bitvectors of infinite width.

* 2-adics can represent even fractions
* Thus, we'll generally restrict to *integer 2-adics*, which are those 2-adics which can be divided into a finite suffix and an infinite prefix which is just a single repeated bit (i.e., either $\ldots 11111$ or $\ldots 00000$).

### Computationally

We think of these infinite sequences *coinductively*. Roughly, this means we regard an infinite sequence as being generated by a statemachine $f : X \to Bool \times X$, where $X$ stands for an arbitrary type of internal states.

Suppose we had two such functions $f_x$ and $f_y$, with internal states $X$, resp. $Y$, then it's straightforward to define, e.g., the bitwise and.
$$
f_{x \mathop{||} y} : (X \times Y) \to Bool \times (X \times Y)
$$
Suppose $f_x(s_x) = (b_x, s'_x)$ and $f_y(s_y) = (b_y, s'_y)$, then
$$
f_{x \mathop{||} y} (s_x, s_y) = ( b_x \mathop{||} b_y,\ (s'_x, s'_y))
$$
The internal states of the bitwise expression is just the pair of states of the constituent bitvectors -- the bitwise operation itself has *no extra state* -- and the output bit is simply given by the bitwise or of the corresponding input bits.

* Addition is implemented by a simple full-adder circuit; now there is a single carry bit of extra state.
* Notice how these all have the property that if their input is an *integer* 2-adic, then the output is also an integer 2-adic.

### Bisimilarity
* Of course, there can be distinct state machines that end up generating the same infinite sequence. 
* Thus, we need an alternative notion of equivalence: Bisimilarity
* States $x_0 \in X$ and $y_0 \in Y$ of state machines $f : X \to Bool \times X$ and $g : Y \to Bool \times Y$ are said to be bisimilar if there exists some relation $R \subseteq X \times Y$ which relates $x_0$ to $y_0$, and such that $x \mathrel{R} y$, for all $x$ and $y$, implies:
	* $f(x).fst = g(x).fst$, and
	* $f(x).snd \mathrel{R} g(y).snd$
* Two state machines generate the same sequence of bits iff they are bisimilar.

* This forms the basis of our decision procedure: if the state types $X$ and $Y$ are *finite*, then bisimilarity of any state machines over these types is decidable!

>[!TODO]
>- Explain why it is decidable
>- Potentially go into a bit more detail about how this is actually implemented?

* The operations we mentioned before (bitwise operations, addition, negation, subtraction) are exactly those that need at most finite extra state, and are thus decidable.

### Multiplication
* In fact, we can multiply 2-adics as well.
* However, this might involve an unbounded state, and is thus *not* decidable by this procedure.
* However, we *can* still use the bisimilarity framework to reason about them, we merely require the user to supply the relation $R$.
* This technique, although not automatic, can give very clean proofs.

